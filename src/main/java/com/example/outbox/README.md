# 아웃박스 패턴 (Outbox Pattern)

---

#### ref: https://techblog.woowahan.com/7835/ , https://microservices.io/patterns/data/transactional-outbox.html

### Outbox Pattern 이란?
<blockquote>
Outbox는 주로 웹 메일에서 ‘보낸 편지함’을 의미합니다. application 에서는 로컬 트랜잭션(동일 저장소를 사용한 트랜잭션)을 사용하여 데이터베이스를 저장하고 이벤트를 발행함에 정합성을 보장하기 위한 패턴
</blockquote>

### ➤ 언제 사용 하나요?
주로 Event Driven Architecture 를 따르는 서비스에서 Message Broker 들을 사용하여 이벤트를 발행하고 연관된 작업을 비동기로 실행합니다.<p></p>
이중 쓰기 문제: 일반적으로 데이터베이스와 메시지 브로커에 별도로 쓰기가 이루어질 때, 트랜잭션 실패나 네트워크 문제로 인해 하나는 성공하고 다른 하나는 실패할 수 있습니다. 이로 인해 시스템 상태가 불일치하게 됩니다.

따라서 서버 통신간 불확실한 통신을 보장하고 싶을때, 분산 Transaction 원자성을 보장 하고싶을때 사용합니다.
<br></br>

### Flow 는 다음과 같아요
- 데이터베이스에 변경을 가할 때, 동시에 "아웃박스 테이블"이라는 특별한 테이블에 전송해야 할 메시지도 함께 기록합니다.
- 메시지 큐 또는 브로커가 아웃박스 테이블을 모니터링하여 기록된 메시지를 전송한 후, 메시지가 성공적으로 전송되었음을 테이블에서 삭제하거나 업데이트합니다.

![outbox.png](..%2F..%2F..%2F..%2F..%2F..%2Fdocs%2Foutbox.png)

### Outbox 패턴의 이점
<blockquote>
- 데이터 일관성 보장: 데이터베이스의 상태와 외부 시스템(메시지 큐)의 상태가 항상 일치하게 됩니다.<br>
- 확장성: 대규모 마이크로서비스 아키텍처에서 특히 유용합니다.<br>
- 재처리 가능: 메시지 전송이 실패하더라도 데이터베이스에 기록된 메시지를 통해 재시도할 수 있습니다.<br>
</blockquote>

### Outbox 패턴의 단점
<blockquote>
복잡성 증가: 아웃박스 테이블을 모니터링하고 관리하는 로직을 추가로 구현해야 합니다.<br>
메시지 지연: 메시지가 처리되기까지 시간이 걸릴 수 있으며, 이는 실시간 처리가 필요한 경우에는 제약이 될 수 있습니다.<br>
</blockquote>


### 메세지 브로커를 활용한 다른 패턴

➤ 아래 패턴들은 분산 서버간의 트랜잭션을 다루는 패턴이에요 

<table class="table">
<tbody>
<tr>
<td><strong> Saga 패턴</strong></td>
<td>

Saga 패턴은 장기 실행 트랜잭션을 관리하는 패턴으로, 각 서비스에서 수행되는 개별 작업을 독립적인 로컬 트랜잭션으로 처리하고, 실패 시 보상 작업을 통해 롤백을 처리하는 방식입니다.

특징
- 로컬 트랜잭션: 각 서비스가 자체적으로 트랜잭션을 처리하여, 중앙 조정자 없이도 분산 트랜잭션이 수행됩니다.
- 보상 트랜잭션: 트랜잭션이 실패하면 이전에 성공했던 작업들을 취소하는 보상 트랜잭션이 실행됩니다.</td>
</tr>
<tr>
<td><strong>2PC(two-phase-commit) 패턴</strong></td>
<td>
2PC 패턴은 중앙 조정자가 여러 분산된 노드 간의 트랜잭션을 원자적으로 수행하기 위해 사용하는 프로토콜입니다. 두 단계로 나뉘어져 진행됩니다:

단계
- Prepare 단계: 중앙 조정자가 모든 참여자에게 트랜잭션 준비를 요청합니다. 각 참여자는 트랜잭션이 준비되었는지 확인하고 "준비 완료" 또는 "실패"를 응답합니다.
- Commit 단계: 모든 참여자가 "준비 완료"라고 응답하면 조정자는 트랜잭션을 커밋하고, 하나라도 실패 시 롤백을 지시합니다.
</td>
</tr>
</tbody>
</table>