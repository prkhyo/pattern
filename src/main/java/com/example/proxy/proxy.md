# 프록시 패턴 (Proxy Pattern)

----


## 프록시 패턴이란?
<blockquote> 
어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴
</blockquote> 
<br>

### ➤ 프록시 패턴의 필요성 <br>

<p><strong>객체에 대한 접근을 제어하거나 성능을 최적화할 때 유용한 디자인 패턴</strong></p>
: 프록시 패턴은 무거운 객체를 지연 로딩하여 성능을 최적화하거나, 네트워크 자원과 같은 원격 객체에 접근할 때, 접근 제어가 필요한 경우에 사용할 수 있다.
이 패턴을 사용하면 클라이언트와 실제 객체 사이에 프록시를 두어 클라이언트의 요청을 필터링하거나, 추가적인 작업을 수행할 수 있다.

  

<br><br>

### ➤ 프록시 패턴의 구조 <br>

<table class="table">
<tbody>
<tr>
<td><strong>Subject</strong></td>
<td>프록시와 실제 객체가 구현하는 공통 인터페이스 또는 추상 클래스로, 클라이언트가 프록시와 실제 객체를 동일하게 다룰 수 있도록 정의한다.
</tr>
<tr>
<td><strong>RealSubject</strong></td>
<td>실제 객체로, 클라이언트가 요청하는 기능을 실제로 수행하는 객체이다.</td>
</tr>
<tr>
<td><strong>Proxy</strong></td>
<td>프록시 객체로, RealSubject에 대한 참조를 가진다. 클라이언트의 요청을 받아 RealSubject의 같은 이름의 메서드를 호출하여 실제 객체에게 전달하거나, 추가적인 작업을 수행한다.</td>
</tr>
</tbody>
</table>


- 프록시 패턴의 구조는 클라이언트가 접근할 Subject와 이에 대한 구현체인 RealSubject, Proxy로 구성된다.
- 호출순서: <strong> Client -> Proxy -> RealSubject -> Subject </strong>


***
<br><br>

## 프록시 패턴의 유형

- **1. 보호 프록시 (Protection Proxy):**
  - 객체에 대한 접근 권한을 제어하기 위해 사용되는 프록시로, 특정 사용자가 특정 메소드나 속성에 접근할 수 없도록 제한하거나, 접근을 허가할 때 사용된다.
  - 적용 예시: 접근 제어, 인증/인가 로직 적용
- **2. 가상 프록시 (Virtual Proxy):** 
  - 무거운 객체의 생성을 지연시켜 성능을 최적화하기 위해 사용되는 프록시로, 객체의 생성이 비용이 많이 들거나, 크기가 큰 리소스를 다루는 경우, 처음부터 객체를 생성하는 대신 필요할 때 생성하는 방식이다.
  - 적용 예시: 대용량 이미지 로드, 원격 서비스 호출
- **3. 스마트 프록시 (Smart Proxy):** 
  -  원본 객체에 추가적인 기능을 제공하는 프록시로, 참조 카운팅, 로깅 등의 추가적인 작업을 수행할 때 사용된다.
  -  적용 예시: 로깅, 성능 모니터링, 데이터베이스 트랜잭션 관리
- **4. 원격 프록시 (Remote Proxy):** 
  - 다른 네트워크나 프로세스에 있는 객체에 대한 접근을 제어하는 프록시로, 클라이언트는 프록시를 통해 원격 객체와 통신하며, 프록시는 네트워크 통신을 추상화하여 클라이언트가 마치 로컬 객체처럼 원격 객체를 사용할 수 있도록 하는 방식이다.
  - 적용 예시: RMI(Remote Method Invocation), gRPC, SOAP 같은 원격 호출에서 사용



***
<br><br>

## 장점과 단점

### ➤ 장점
- <strong>접근 제어:</strong> 클라이언트가 실제 객체에 직접 접근하지 않도록 제어하여 객체의 접근을 관리하고, 권한 검사를 수행할 수 있다.
- <strong>지연 초기화:</strong> 실제 객체의 생성과 초기화를 지연시켜, 필요한 순간에만 생성 및 초기화하여 성능을 최적화할 수 있다.
- <strong>캐싱:</strong> 결과를 캐싱하여 중복된 계산을 피하고 성능을 향상시킬 수 있다.
- <strong>유효성 검사:</strong> 실제 객체에 접근하기 전에 데이터의 유효성을 검증할 수 있다.
- <strong>로깅 및 감사 기능:</strong> 프록시를 통해 객체 사용을 로깅하거나 추가적인 작업을 수행할 수 있다.
- <strong>원격 액세스:</strong> 원격 프록시를 사용하여 다른 시스템에서 실행 중인 객체에 접근할 수 있으며, 분산 시스템에서 객체 간 통신을 용이하게 할 수 있다.

### ➤ 단점
- <strong>복잡성 증가:</strong> 추가적인 객체를 도입하기 때문에 코드의 복잡성이 증가할 수 있다.
- <strong>디자인 복잡성:</strong> 프록시 패턴을 오용하면 코드를 과도하게 복잡하게 만들 수 있다.
- <strong>지연 시간 추가 가능성:</strong> 프록시가 추가되면서 요청 처리에 약간의 지연 시간이 발생할 수 있다.

***
<br><br>


## 프록시 패턴: 개방-폐쇄 원칙 (OCP) / 의존성 역전 원칙 (DIP)

프록시 패턴은 개방-폐쇄 원칙(OCP)과 의존성 역전 원칙(DIP)을 준수하는 구조적 디자인 패턴이다.
### 개방-폐쇄 원칙 (OCP)
- 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.
- Proxy 클래스는 RealSubject 클래스를 확장하여 접근 제어 및 로깅과 같은 추가 작업을 수행한다. 이를 통해 RealSubject의 코드를 수정하지 않고도 기능을 확장할 수 있다는 점에서 개방-폐쇄 원칙을 준수한다.

<br>

### 의존성 역전 원칙 (DIP)
- 고수준 모듈(시스템의 주요 비즈니스 로직)은 저수준 모듈(비즈니스 로직을 처리하기 위해 호출하는 개별적인 기능이나 세부적인 구현)에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다.
- 즉, 세부 사항(구현)은 추상화(인터페이스)에 의존해야 한다. 구체적인 클래스가 아닌, 인터페이스나 추상 클래스에 의존함으로써 유연한 설계를 가능하게 한다.
- 클라이언트 요청 코드는 Subject 인터페이스에 의존하고 있으며, 구체적인 클래스인 RealSubject나 Proxy에 의존하지 않습니다. 따라서 클라이언트 코드와 구현 클래스 간의 결합도가 낮아져 유연한 설계를 가능하여 의존성 역전 원칙을 준수합니다.


***
<br><br>


## 기타 디자인 패턴의 비교
<table class="table">
<tbody>
<tr>
<td><strong>데코레이터 패턴</strong></td>
<td>데코레이터는 객체에 추가적인 기능을 동적으로 부여하는 반면, 프록시는 실제 객체 자체에 추가 기능을 부여하는 것이 아닌 대리인 객체가 실제 객체에 대한 접근을 제어하는 과정에서 추가적인 기능을 수행할 수 있다.</td>
</tr>
<tr>
<td><strong>어댑터 패턴</strong></td>
<td>어댑터는 인터페이스를 변환하여 호환성을 제공하지만, 프록시는 동일한 인터페이스를 사용하면서 접근을 제어한다.</td>
</tr>
</tbody>
</table>
